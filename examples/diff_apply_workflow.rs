//! Example demonstrating the diff-first apply workflow with quality gates
//!
//! This example shows how AI-generated changes are:
//! 1. Presented as diffs for human review
//! 2. Validated through quality gates (format, lint, compile, test, security)
//! 3. Applied safely with backup and rollback capabilities
//!
//! Run with: cargo run --example diff_apply_workflow

use devkit::codegen::diff_apply::{
    DiffApplySystem, QualityGateConfig, ChangeSet, FileDiff, ChangeType, 
    DiffMetadata, ChangeSetMetadata
};
use std::path::PathBuf;
use chrono::Utc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸš€ DevKit Diff-First Apply Workflow Demo");
    println!("==========================================\n");
    
    let project_root = std::env::current_dir()?;
    
    // Create a diff apply system with quality gates
    let config = QualityGateConfig {
        enabled_gates: vec![
            "format".to_string(),
            "lint".to_string(), 
            "compile".to_string(),
            "test".to_string(),
            "security".to_string(),
        ],
        auto_apply_on_pass: false, // Require manual approval
        require_all_gates: false, // Don't stop on first failure
        timeout_seconds: 120,
        parallel_execution: false, // Run sequentially for demo
        custom_commands: std::collections::HashMap::new(),
    };
    
    let mut diff_system = DiffApplySystem::new(config, &project_root)?;
    
    // Simulate an AI-generated changeset
    println!("ğŸ“ Creating sample changeset...");
    
    let sample_rust_code = r#"//! Sample module generated by AI
//!
//! This demonstrates a simple calculator with basic operations.

/// Simple calculator struct
#[derive(Debug, Clone, Default)]
pub struct Calculator {
    value: f64,
}

impl Calculator {
    /// Create a new calculator
    pub fn new() -> Self {
        Self { value: 0.0 }
    }
    
    /// Add a value
    pub fn add(&mut self, x: f64) -> &mut Self {
        self.value += x;
        self
    }
    
    /// Subtract a value
    pub fn subtract(&mut self, x: f64) -> &mut Self {
        self.value -= x;
        self
    }
    
    /// Multiply by a value
    pub fn multiply(&mut self, x: f64) -> &mut Self {
        self.value *= x;
        self
    }
    
    /// Get the current value
    pub fn value(&self) -> f64 {
        self.value
    }
    
    /// Reset the calculator
    pub fn reset(&mut self) -> &mut Self {
        self.value = 0.0;
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_calculator_operations() {
        let mut calc = Calculator::new();
        
        let result = calc
            .add(5.0)
            .multiply(2.0)
            .subtract(3.0)
            .value();
            
        assert_eq!(result, 7.0);
    }
    
    #[test]
    fn test_calculator_reset() {
        let mut calc = Calculator::new();
        calc.add(10.0);
        assert_eq!(calc.value(), 10.0);
        
        calc.reset();
        assert_eq!(calc.value(), 0.0);
    }
}
"#;

    // Create a file diff
    let file_diff = FileDiff {
        file_path: PathBuf::from("src/calculator.rs"),
        original_content: None, // New file
        new_content: sample_rust_code.to_string(),
        diff_text: DiffApplySystem::generate_diff(
            None, 
            sample_rust_code, 
            &PathBuf::from("src/calculator.rs")
        ),
        change_type: ChangeType::Create,
        metadata: DiffMetadata {
            created_at: Utc::now(),
            agent_id: "codegen_agent".to_string(),
            task_id: "generate_calculator".to_string(),
            confidence_score: 0.92,
            estimated_lines_changed: sample_rust_code.lines().count(),
            language: Some("rust".to_string()),
            description: "AI-generated calculator module with tests".to_string(),
        },
    };
    
    // Create mod.rs update to include the new module
    let mod_rs_update = r#"//! DevKit example modules

pub mod calculator;
pub mod examples {
    pub use super::calculator::Calculator;
}
"#;

    let mod_diff = FileDiff {
        file_path: PathBuf::from("src/mod.rs"),
        original_content: Some("//! DevKit example modules\n".to_string()),
        new_content: mod_rs_update.to_string(),
        diff_text: DiffApplySystem::generate_diff(
            Some("//! DevKit example modules\n"),
            mod_rs_update,
            &PathBuf::from("src/mod.rs")
        ),
        change_type: ChangeType::Modify,
        metadata: DiffMetadata {
            created_at: Utc::now(),
            agent_id: "codegen_agent".to_string(),
            task_id: "update_module_exports".to_string(),
            confidence_score: 0.98,
            estimated_lines_changed: 4,
            language: Some("rust".to_string()),
            description: "Update module exports to include calculator".to_string(),
        },
    };
    
    let mut changeset = ChangeSet {
        id: "calc_module_001".to_string(),
        title: "Add Calculator Module".to_string(),
        description: "AI-generated calculator module with comprehensive tests and documentation".to_string(),
        files: vec![file_diff, mod_diff],
        metadata: ChangeSetMetadata {
            created_at: Utc::now(),
            agent_id: "codegen_agent".to_string(),
            task_id: "implement_calculator_feature".to_string(),
            total_files: 2,
            total_lines_added: sample_rust_code.lines().count() + 4,
            total_lines_removed: 0,
            affects_tests: true,
            affects_dependencies: false,
        },
        validation_results: None,
    };
    
    println!("âœ… Sample changeset created!");
    println!("   - {} files affected", changeset.files.len());
    println!("   - {} lines added", changeset.metadata.total_lines_added);
    
    // Step 1: Preview the changes
    println!("\nğŸ“‹ Step 1: Previewing changes...");
    println!("{}", "=".repeat(50));
    
    let preview = diff_system.preview_changeset(&changeset).await?;
    println!("{}", preview);
    
    // Step 2: Validate through quality gates
    println!("ğŸ” Step 2: Running quality gates validation...");
    println!("{}", "=".repeat(50));
    
    println!("â³ Running validation pipeline...");
    match diff_system.validate_changeset(&mut changeset, &project_root).await {
        Ok(_) => {
            println!("âœ… Validation completed!");
            
            if let Some(ref results) = changeset.validation_results {
                println!("\nğŸ“Š Validation Results:");
                println!("   Overall Status: {:?}", results.overall_status);
                println!("   Can Auto-Apply: {}", results.can_auto_apply);
                
                println!("\nğŸšª Quality Gates:");
                for (gate_name, gate_result) in &results.gates {
                    let status_icon = match gate_result.status {
                        devkit::codegen::diff_apply::GateStatus::Passed => "âœ…",
                        devkit::codegen::diff_apply::GateStatus::Failed => "âŒ",
                        devkit::codegen::diff_apply::GateStatus::Warning => "âš ï¸",
                        devkit::codegen::diff_apply::GateStatus::Skipped => "â­ï¸",
                        devkit::codegen::diff_apply::GateStatus::Error => "ğŸ’¥",
                    };
                    
                    println!("   {} {} - {} ({}ms)", 
                        status_icon,
                        gate_name,
                        gate_result.message,
                        gate_result.execution_time_ms
                    );
                    
                    if let Some(ref details) = gate_result.details {
                        let preview_details = if details.len() > 200 {
                            format!("{}...", &details[..200])
                        } else {
                            details.clone()
                        };
                        println!("     Details: {}", preview_details);
                    }
                }
                
                if !results.warnings.is_empty() {
                    println!("\nâš ï¸  Warnings:");
                    for warning in &results.warnings {
                        println!("   - {}", warning);
                    }
                }
                
                if !results.errors.is_empty() {
                    println!("\nâŒ Errors:");
                    for error in &results.errors {
                        println!("   - {}", error);
                    }
                }
            }
        }
        Err(e) => {
            println!("âŒ Validation failed: {}", e);
        }
    }
    
    // Step 3: Apply or suggest manual review
    println!("\nğŸ¯ Step 3: Apply Decision...");
    println!("{}", "=".repeat(50));
    
    if let Some(ref results) = changeset.validation_results {
        if results.can_auto_apply {
            println!("âœ… All quality gates passed! Ready for auto-apply.");
            println!("ğŸ’¡ In a real system, you could now apply the changes with:");
            println!("   diff_system.apply_changeset(&changeset, &project_root, false).await");
        } else {
            println!("âš ï¸  Quality gates require manual review before applying.");
            println!("ğŸ”§ Recommended actions:");
            
            for error in &results.errors {
                println!("   - Fix: {}", error);
            }
            
            if !results.warnings.is_empty() {
                println!("   - Review warnings and decide if acceptable");
            }
            
            println!("\nğŸ’¡ After fixes, you could apply with:");
            println!("   diff_system.apply_changeset(&changeset, &project_root, true).await");
        }
    }
    
    // Step 4: Demonstrate rollback capability
    println!("\nâ†©ï¸  Step 4: Rollback Capabilities...");
    println!("{}", "=".repeat(50));
    
    let applied_changesets = diff_system.get_applied_changesets();
    if !applied_changesets.is_empty() {
        println!("ğŸ“¦ Applied changesets available for rollback:");
        for changeset in applied_changesets {
            println!("   - {} ({})", changeset.title, changeset.id);
        }
        println!("\nğŸ’¡ To rollback a changeset:");
        println!("   diff_system.rollback_changeset(\"changeset_id\", &project_root).await");
    } else {
        println!("ğŸ“ No changesets have been applied yet.");
        println!("ğŸ’¡ After applying changes, they would appear here for rollback.");
    }
    
    // Step 5: Configuration and customization
    println!("\nâš™ï¸  Step 5: Configuration Options...");
    println!("{}", "=".repeat(50));
    
    println!("ğŸ”§ Quality Gate Configuration:");
    println!("   - Format checking: Ensures code follows style guidelines");
    println!("   - Lint checking: Catches potential bugs and code smells");
    println!("   - Compilation: Verifies code compiles without errors");
    println!("   - Testing: Runs test suite to ensure functionality");
    println!("   - Security: Scans for common security vulnerabilities");
    
    println!("\nğŸ›ï¸  Customizable Settings:");
    println!("   - Auto-apply on pass: {}", results.as_ref().map_or(false, |r| false));
    println!("   - Require all gates: true");
    println!("   - Parallel execution: false");
    println!("   - Timeout: 120 seconds");
    
    println!("\nğŸ”„ Workflow Benefits:");
    println!("   âœ… Safe application of AI-generated changes");
    println!("   âœ… Comprehensive quality validation");
    println!("   âœ… Full audit trail and rollback capability");
    println!("   âœ… Diff-first review for human oversight");
    println!("   âœ… Configurable quality gates per project");
    
    println!("\nğŸ‰ Demo completed! The diff-first apply system provides a robust,");
    println!("   production-ready workflow for safely applying AI-generated code changes.");
    
    Ok(())
}
"