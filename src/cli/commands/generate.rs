use crate::cli::{CliRunner, GenerateArgs};
use crate::codegen::stubs;
use std::fs;
use std::io::{self, Write};
use std::path::PathBuf;
use std::sync::Arc;

pub async fn run(
    runner: &mut CliRunner,
    args: GenerateArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    runner.print_info(&format!(
        "🤖 Generating code from prompt: \"{}\"",
        args.prompt
    ));

    // Analyze the prompt and infer language
    let language = determine_language(&args);
    
    if runner.verbose() {
        runner.print_verbose(&format!(
            "Language: {:?}, Strategy: {}", 
            language, args.strategy
        ));
    }

    // Show progress for generation  
    if !runner.quiet() {
        print!("🔄 Generating code...");
        io::stdout().flush()?;
    }

    // Decide scaffolding
    let mut scaffold = args.scaffold;
    if args.single_file || args.no_scaffold { scaffold = false; }

    if scaffold && !args.preview {
        scaffold_project(runner, &args, language.as_deref()).await?;
        if !runner.quiet() { println!(" ✅"); }
        runner.print_success("Project scaffolded successfully!");
        return Ok(());
    }

    // Single-file path
    let generated_code = match generate_with_engine(runner, &args, language.clone()).await {
        Ok(code) => code,
        Err(e) => {
            runner.print_warning(&format!(
                "AI/codegen pipeline unavailable ({}). Falling back to stub generator.",
                e
            ));
            generate_code_with_stubs(&args, language.as_deref())
        }
    };
    
    if !runner.quiet() {
        println!(" ✅");
    }

    // Handle the generated code based on mode
    if args.preview {
        display_generated_code(runner, &generated_code, &args, language.as_deref())?;
    } else {
        save_generated_code(runner, &generated_code, &args, language.as_deref()).await?;
    }

    runner.print_success("Code generation completed successfully!");
    Ok(())
}

async fn scaffold_project(
    runner: &CliRunner,
    args: &GenerateArgs,
    language: Option<&str>,
) -> Result<(), Box<dyn std::error::Error>> {
    // Determine root directory
    let root = if let Some(root) = &args.root {
        root.clone()
    } else if let Some(out) = &args.output {
        // If output looks like a file (has extension), use its parent; else use as dir
        if out.extension().is_some() {
            out.parent().map(|p| p.to_path_buf()).unwrap_or_else(|| PathBuf::from("."))
        } else {
            out.clone()
        }
    } else {
        // derive from prompt
        let base = stubs::suggest_filename(&args.prompt, language).replace('.', "_");
        PathBuf::from(base)
    };

    // If root exists and not forced, abort if non-empty
    if root.exists() && !args.force {
        if root.is_file() || std::fs::read_dir(&root)?.next().is_some() {
            return Err(format!(
                "Target '{}' exists and is not empty. Use --force to overwrite.",
                root.display()
            )
            .into());
        }
    }

    // Build plan (path -> content)
    let mut plan: Vec<(PathBuf, String)> = Vec::new();

    let lang = language.unwrap_or("rust").to_lowercase();
    let stack = args.stack.as_deref().unwrap_or("").to_lowercase();

    match (lang.as_str(), stack.as_str()) {
        ("rust", s) if s == "rust-axum" => {
            let pkg = root.file_name().and_then(|s| s.to_str()).unwrap_or("app");
let cargo = format!("[package]\nname=\"{}\"\nversion=\"0.1.0\"\nedition=\"2021\"\n\n[dependencies]\naxum=\"0.7\"\ntokio={{ version=\"1\", features=[\"full\"] }}\ntracing=\"0.1\"\n", pkg);
            let main_rs = r#"use axum::{routing::get, Router};
use std::net::SocketAddr;

#[tokio::main]
async fn main() {
    let app = Router::new().route("/", get(|| async { "ok" }));
    let addr: SocketAddr = "127.0.0.1:3000".parse().unwrap();
    axum::Server::bind(&addr).serve(app.into_make_service()).await.unwrap();
}
"#.to_string();
            plan.push((root.join("Cargo.toml"), cargo));
            plan.push((root.join("src/main.rs"), main_rs));
            plan.push((root.join("README.md"), format!("# {}\nGenerated by DevKit (axum)", pkg)));
        }
        ("rust", s) if s == "rust-actix" => {
            let pkg = root.file_name().and_then(|s| s.to_str()).unwrap_or("app");
            let cargo = format!("[package]\nname=\"{}\"\nversion=\"0.1.0\"\nedition=\"2021\"\n\n[dependencies]\nactix-web=\"4\"\n", pkg);
            let main_rs = r#"use actix_web::{get, App, HttpServer, Responder};
#[get("/")]
async fn index() -> impl Responder { "ok" }
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| App::new().service(index)).bind(("127.0.0.1", 3000))?.run().await
}
"#.to_string();
            plan.push((root.join("Cargo.toml"), cargo));
            plan.push((root.join("src/main.rs"), main_rs));
            plan.push((root.join("README.md"), format!("# {}\nGenerated by DevKit (actix)", pkg)));
        }
        ("rust", s) if s == "rust-axum-sqlx" => {
            let pkg = root.file_name().and_then(|s| s.to_str()).unwrap_or("app");
            let cargo = format!("[package]\nname=\"{}\"\nversion=\"0.1.0\"\nedition=\"2021\"\n\n[dependencies]\naxum=\"0.7\"\ntokio={{ version=\"1\", features=[\"full\"] }}\ntracing=\"0.1\"\nsqlx={{ version=\"0.7\", features=[\"runtime-tokio\", \"postgres\"] }}\n", pkg);
            let main_rs = r#"use axum::{routing::get, Router};
use sqlx::PgPool;
use std::net::SocketAddr;

#[tokio::main]
async fn main() {
    let database_url = std::env::var("DATABASE_URL").unwrap_or_else(|_| "postgres://postgres:postgres@localhost/app".into());
    let pool = PgPool::connect(&database_url).await.expect("db");

    let app = Router::new().route("/", get(|| async { "ok" })).with_state(pool);
    let addr: SocketAddr = "127.0.0.1:3000".parse().unwrap();
    axum::Server::bind(&addr).serve(app.into_make_service()).await.unwrap();
}
"#.to_string();
            plan.push((root.join("Cargo.toml"), cargo));
            plan.push((root.join("src/main.rs"), main_rs));
            plan.push((root.join("README.md"), format!("# {}\nGenerated by DevKit (axum+sqlx)", pkg)));
        }
        ("javascript", s) if s == "node-express" || s.is_empty() => {
            let pkg = root.file_name().and_then(|s| s.to_str()).unwrap_or("app");
            let package_json = format!("{{\n  \"name\": \"{}\",\n  \"version\": \"0.1.0\",\n  \"type\": \"module\",\n  \"scripts\": {{ \"start\": \"node src/index.js\" }},\n  \"dependencies\": {{ \"express\": \"^4\" }}\n}}\n", pkg);
            let index_js = r#"import express from 'express';
const app = express();
app.get('/', (req,res)=>res.send('ok'));
app.listen(3000, ()=>console.log('http://localhost:3000'));
"#.to_string();
            plan.push((root.join("package.json"), package_json));
            plan.push((root.join("src/index.js"), index_js));
            plan.push((root.join("README.md"), format!("# {}\nGenerated by DevKit (express)", pkg)));
        }
        ("typescript", s) if s == "nextjs" => {
            let pkg = root.file_name().and_then(|s| s.to_str()).unwrap_or("web");
            let package_json = format!("{{\n  \"name\": \"{}\",\n  \"private\": true,\n  \"scripts\": {{ \"dev\": \"next dev\" }},\n  \"dependencies\": {{ \"next\": \"^14\", \"react\": \"^18\", \"react-dom\": \"^18\" }}\n}}\n", pkg);
            let tsconfig = "{\n  \"compilerOptions\": { \"strict\": true }\n}\n".to_string();
            plan.push((root.join("package.json"), package_json));
            plan.push((root.join("tsconfig.json"), tsconfig));
            plan.push((root.join("app/page.tsx"), "export default function Page(){return <>ok</>}\n".to_string()));
            plan.push((root.join("README.md"), format!("# {}\nGenerated by DevKit (nextjs)", pkg)));
        }
        ("typescript", s) if s == "node-nest" => {
            let pkg = root.file_name().and_then(|s| s.to_str()).unwrap_or("api");
            let package_json = format!("{{\n  \"name\": \"{}\",\n  \"version\": \"0.1.0\",\n  \"scripts\": {{ \"start\": \"ts-node-dev --respawn src/main.ts\" }},\n  \"dependencies\": {{ \"@nestjs/common\": \"^10\", \"@nestjs/core\": \"^10\", \"reflect-metadata\": \"^0.1.13\", \"rxjs\": \"^7\" }},\n  \"devDependencies\": {{ \"typescript\": \"^5\", \"ts-node-dev\": \"^2\", \"@types/node\": \"^20\" }}\n}}\n", pkg);
            let tsconfig = "{\n  \"compilerOptions\": { \"module\": \"commonjs\", \"target\": \"es2019\", \"experimentalDecorators\": true, \"emitDecoratorMetadata\": true, \"sourceMap\": true, \"strict\": true }\n}\n".to_string();
            let main_ts = r#"import 'reflect-metadata';
import { NestFactory } from '@nestjs/core';
import { Module, Controller, Get } from '@nestjs/common';

@Controller()
class AppController { @Get() root() { return 'ok'; } }
@Module({ controllers: [AppController] })
class AppModule {}

async function bootstrap() { const app = await NestFactory.create(AppModule); await app.listen(3000); }
bootstrap();
"#.to_string();
            plan.push((root.join("package.json"), package_json));
            plan.push((root.join("tsconfig.json"), tsconfig));
            plan.push((root.join("src/main.ts"), main_ts));
            plan.push((root.join("README.md"), format!("# {}\nGenerated by DevKit (NestJS)", pkg)));
        }
        ("python", s) if s == "python-fastapi" || s.is_empty() => {
            let main_py = r#"from fastapi import FastAPI
app = FastAPI()
@app.get('/')
def root():
    return {\"status\":\"ok\"}
"#.to_string();
            plan.push((root.join("requirements.txt"), "fastapi\nuvicorn\n".to_string()));
            plan.push((root.join("src/main.py"), main_py));
            plan.push((root.join("README.md"), "# FastAPI app\nGenerated by DevKit\n".to_string()));
        }
        ("python", s) if s == "python-fastapi-sqlalchemy" => {
            let main_py = r#"from fastapi import FastAPI
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "sqlite:///./app.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

app = FastAPI()

@app.get('/')
def root():
    return {\"status\": \"ok\"}
"#.to_string();
            plan.push((root.join("requirements.txt"), "fastapi\nuvicorn\nsqlalchemy\n".to_string()));
            plan.push((root.join("src/main.py"), main_py));
            plan.push((root.join("README.md"), "# FastAPI + SQLAlchemy app\nGenerated by DevKit\n".to_string()));
        }
        _ => {
            // Default to previous simple per-language scaffolds
            let lang = lang; // reuse
            match lang.as_str() {
                "rust" | "rs" => {
                    let pkg_name = root.file_name().and_then(|s| s.to_str()).unwrap_or("app");
                    let cargo = format!("[package]\nname=\"{}\"\nversion=\"0.1.0\"\nedition=\"2021\"\n", pkg_name);
                    plan.push((root.join("Cargo.toml"), cargo));
                    let code = match generate_with_engine(runner, args, Some("rust".to_string())).await { Ok(c)=>c, Err(_)=> stubs::generate_code_stub(&args.prompt, Some("rust")) };
                    plan.push((root.join("src/main.rs"), code));
                }
                "typescript" | "ts" => {
                    plan.push((root.join("package.json"), "{\n  \"name\": \"app\", \"version\": \"0.1.0\"\n}\n".to_string()));
                    let code = match generate_with_engine(runner, args, Some("typescript".to_string())).await { Ok(c)=>c, Err(_)=> stubs::generate_code_stub(&args.prompt, Some("typescript")) };
                    plan.push((root.join("src/index.ts"), code));
                }
                "javascript" | "js" => {
                    plan.push((root.join("package.json"), "{\n  \"name\": \"app\", \"version\": \"0.1.0\"\n}\n".to_string()));
                    let code = match generate_with_engine(runner, args, Some("javascript".to_string())).await { Ok(c)=>c, Err(_)=> stubs::generate_code_stub(&args.prompt, Some("javascript")) };
                    plan.push((root.join("src/index.js"), code));
                }
                "python" | "py" => {
                    plan.push((root.join("requirements.txt"), String::new()));
                    let code = match generate_with_engine(runner, args, Some("python".to_string())).await { Ok(c)=>c, Err(_)=> stubs::generate_code_stub(&args.prompt, Some("python")) };
                    plan.push((root.join("src/main.py"), code));
                }
                _ => {
                    let code = match generate_with_engine(runner, args, language.map(|s| s.to_string())).await { Ok(c)=>c, Err(_)=> stubs::generate_code_stub(&args.prompt, language) };
                    plan.push((root.join("src/main.txt"), code));
                }
            }
        }
    }

    // Dry run: print plan and exit
    if args.dry_run {
        runner.print_info("Scaffold plan (dry-run):");
        for (path, _) in &plan {
            runner.print_output(&format!("  - {}\n", path.display()), None);
        }
        return Ok(());
    }

    // Write plan to disk
    for (path, content) in plan {
        if let Some(parent) = path.parent() { fs::create_dir_all(parent)?; }
        if path.exists() && !args.force { return Err(format!("Refusing to overwrite {} (use --force)", path.display()).into()); }
        fs::write(path, content)?;
    }

    Ok(())
}
/// Determine the language to use for code generation
fn determine_language(args: &GenerateArgs) -> Option<String> {
    // First, check if language was explicitly specified
    if let Some(lang) = &args.language {
        return Some(lang.clone());
    }

    // Then, try to infer from output path
    if let Some(output_path) = &args.output {
        return stubs::infer_language_from_context(&args.prompt, Some(output_path));
    }

    // Finally, try to infer from prompt
    stubs::infer_language_from_context(&args.prompt, None)
}

/// Try real engine (AI + templates) first
async fn generate_with_engine(
    runner: &CliRunner,
    args: &GenerateArgs,
    language: Option<String>,
) -> Result<String, Box<dyn std::error::Error>> {
    use crate::ai::AIManager;
    use crate::codegen::{CodeGenerator, GenerationConfig, GenerationRequest};
    use crate::context::CodebaseContext;

    // Build generator
    let mut generator = CodeGenerator::new()?;

    // Attach AI manager if possible
    let cfg = runner.config_manager().config().clone();
    if let Ok(ai) = AIManager::from_config(&cfg).await {
        generator.set_ai_manager(Arc::new(ai));
    }

    // Build request
    let mut gen_cfg = GenerationConfig::default();
    gen_cfg.target_language = language.clone();
    if let Some(t) = args.temperature { gen_cfg.temperature = Some(t as f64); }
    if let Some(mt) = args.max_tokens { gen_cfg.max_tokens = Some(mt); }

    let request = GenerationRequest {
        prompt: args.prompt.clone(),
        file_path: args.output.as_ref().map(|p| p.display().to_string()),
        context: CodebaseContext::default(),
        config: gen_cfg,
        constraints: vec![],
    };

    let result = generator.generate_from_prompt(request).await?;
    Ok(result.generated_code)
}

/// Generate code using our stub system
fn generate_code_with_stubs(args: &GenerateArgs, language: Option<&str>) -> String {
    // Enhance prompt with context if provided
    let enhanced_prompt = if !args.context.is_empty() {
        let mut context_content = String::new();
        for context_file in &args.context {
            if let Ok(content) = fs::read_to_string(context_file) {
                context_content.push_str(&format!(
                    "\n// Context from {}:\n{}",
                    context_file.display(),
                    content
                ));
            }
        }

        if !context_content.is_empty() {
            format!(
                "{}\n\nContext:\n{}",
                args.prompt, context_content
            )
        } else {
            args.prompt.clone()
        }
    } else {
        args.prompt.clone()
    };

    stubs::generate_code_stub(&enhanced_prompt, language)
}

fn display_generated_code(
    runner: &CliRunner,
    code: &str,
    args: &GenerateArgs,
    language: Option<&str>,
) -> Result<(), Box<dyn std::error::Error>> {
    runner.print_info("📝 Generated Code (Preview Mode):");
    
    // Use the enhanced code display from chat command
    runner.print_code(code);

    // Show where it would be saved
    if let Some(output_path) = &args.output {
        runner.print_info(&format!("📁 Would save to: {}", output_path.display()));
    } else {
        let filename = stubs::suggest_filename(&args.prompt, language);
        runner.print_info(&format!("📁 Would save to: {}", filename));
    }

    Ok(())
}

async fn save_generated_code(
    runner: &CliRunner,
    code: &str,
    args: &GenerateArgs,
    language: Option<&str>,
) -> Result<(), Box<dyn std::error::Error>> {
    let output_path = if let Some(path) = &args.output {
        path.clone()
    } else {
        // Use the shared filename suggestion from stubs
        PathBuf::from(stubs::suggest_filename(&args.prompt, language))
    };

    // Ensure parent directory exists
    if let Some(parent) = output_path.parent() {
        if !parent.exists() {
            fs::create_dir_all(parent)?;
            runner.print_verbose(&format!("Created directory: {}", parent.display()));
        }
    }

    // Write the generated code to file
    fs::write(&output_path, code)?;

    runner.print_success(&format!("💾 Code saved to: {}", output_path.display()));

    // Show code statistics
    let lines = code.lines().count();
    let chars = code.len();
    runner.print_info(&format!(
        "📊 Generated {} lines ({} characters)",
        lines, chars
    ));

    Ok(())
}
